# cve_enricher.py
"""
SAINT CVE Enricher Lambda
Scans rules for CVE references and fetches CVE data from NVD API on-demand.

Features:
- Pattern-based CVE extraction from rule content, names, descriptions, tags
- On-demand CVE fetching from NVD API (only when referenced by rules)
- CVE data caching and validation
- Rate limiting and retry logic for NVD API
- Batch processing for efficiency
- Comprehensive logging and metrics
"""
import json
import logging
import re
import requests
import time
from typing import Set, List, Dict, Any, Optional
from datetime import datetime, timezone

from saint_datamodel import db_session
from saint_datamodel.models import DetectionRule, CveEntry, RuleCveMapping

# Setup logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

class CveEnricher:
    # CVE pattern matching
    CVE_PATTERN = re.compile(r'CVE-(\d{4})-(\d{4,})', re.IGNORECASE)
    
    # NVD API configuration
    NVD_API_BASE = 'https://services.nvd.nist.gov/rest/json/cves/2.0'
    NVD_RATE_LIMIT = 5  # requests per second (NIST limit without API key)
    NVD_TIMEOUT = 30  # seconds
    
    def __init__(self):
        self.processed_count = 0
        self.cves_found = 0
        self.cves_fetched = 0
        self.cves_cached = 0
        self.mappings_created = 0
        self.mappings_updated = 0
        self.api_calls = 0
        self.api_errors = 0
        self.last_api_call = 0
        
    def enrich_rules(self, rule_ids: List[int] = None) -> Dict[str, Any]:
        """
        Main enrichment method - scans rules for CVE references and creates mappings.
        """
        logger.info(f"Starting CVE enrichment for {len(rule_ids) if rule_ids else 'all'} rules")
        
        with db_session() as session:
            # Get rules to process
            rules = self._get_rules_to_process(session, rule_ids)
            
            if not rules:
                logger.info("No rules found for CVE enrichment")
                return self._create_result_summary()
            
            logger.info(f"Processing {len(rules)} rules for CVE enrichment")
            
            # Process rules in batches
            batch_size = 25  # Smaller batches for CVE API calls
            for i in range(0, len(rules), batch_size):
                batch = rules[i:i + batch_size]
                self._process_rule_batch(batch, session)
                
                # Commit batch
                session.commit()
                logger.info(f"Processed batch {i//batch_size + 1}/{(len(rules)-1)//batch_size + 1}")
                
                # Rate limiting between batches
                time.sleep(1)
            
            logger.info(f"CVE enrichment complete: {self._create_result_summary()}")
            return self._create_result_summary()
    
    def _get_rules_to_process(self, session, rule_ids: List[int] = None) -> List[DetectionRule]:
        """Get rules that need CVE enrichment."""
        query = session.query(DetectionRule).filter(DetectionRule.is_active == True)
        
        if rule_ids:
            query = query.filter(DetectionRule.id.in_(rule_ids))
        
        return query.all()
    
    def _process_rule_batch(self, rules: List[DetectionRule], session):
        """Process a batch of rules for CVE enrichment."""
        for rule in rules:
            try:
                self._enrich_single_rule(rule, session)
                self.processed_count += 1
            except Exception as e:
                logger.error(f"Failed to process rule {rule.id}: {e}")
    
    def _enrich_single_rule(self, rule: DetectionRule, session):
        """Enrich a single rule with CVE mappings."""
        # Extract CVE IDs from all rule sources
        cve_ids = self._extract_cves_from_rule(rule)
        
        if not cve_ids:
            return
        
        self.cves_found += len(cve_ids)
        logger.debug(f"Rule {rule.id} references CVEs: {', '.join(cve_ids)}")
        
        # Process each CVE
        for cve_id in cve_ids:
            cve_entry = self._get_or_fetch_cve(cve_id, session)
            if cve_entry:
                self._create_or_update_mapping(rule, cve_entry, session)
    
    def _extract_cves_from_rule(self, rule: DetectionRule) -> Set[str]:
        """Extract CVE IDs from all rule sources."""
        cve_ids = set()
        
        # 1. Extract from rule content
        if rule.rule_content:
            content_cves = self._extract_cves_from_text(rule.rule_content)
            cve_ids.update(content_cves)
        
        # 2. Extract from rule name
        if rule.name:
            name_cves = self._extract_cves_from_text(rule.name)
            cve_ids.update(name_cves)
        
        # 3. Extract from description
        if rule.description:
            desc_cves = self._extract_cves_from_text(rule.description)
            cve_ids.update(desc_cves)
        
        # 4. Extract from tags
        if rule.tags:
            for tag in rule.tags:
                if isinstance(tag, str):
                    tag_cves = self._extract_cves_from_text(tag)
                    cve_ids.update(tag_cves)
        
        # 5. Extract from metadata (if already exists)
        if rule.rule_metadata and 'extracted_cve_ids' in rule.rule_metadata:
            extracted = rule.rule_metadata['extracted_cve_ids']
            if isinstance(extracted, list):
                for cve in extracted:
                    if self.CVE_PATTERN.match(cve):
                        cve_ids.add(cve.upper())
        
        return cve_ids
    
    def _extract_cves_from_text(self, text: str) -> Set[str]:
        """Extract CVE IDs from text using regex."""
        matches = self.CVE_PATTERN.findall(text)
        cve_ids = set()
        
        for match in matches:
            year = match[0]
            number = match[1]
            cve_id = f"CVE-{year}-{number}"
            cve_ids.add(cve_id.upper())
        
        return cve_ids
    
    def _get_or_fetch_cve(self, cve_id: str, session) -> Optional[CveEntry]:
        """Get CVE from database or fetch from NVD API if not exists."""
        # Check if CVE already exists in database
        cve_entry = session.query(CveEntry).filter(
            CveEntry.cve_id == cve_id
        ).first()
        
        if cve_entry:
            self.cves_cached += 1
            logger.debug(f"CVE {cve_id} found in database")
            return cve_entry
        
        # Fetch from NVD API
        cve_entry = self._fetch_cve_from_nvd(cve_id, session)
        if cve_entry:
            self.cves_fetched += 1
            logger.info(f"Fetched CVE {cve_id} from NVD API")
            return cve_entry
        
        return None
    
    def _fetch_cve_from_nvd(self, cve_id: str, session) -> Optional[CveEntry]:
        """Fetch CVE data from NVD API with rate limiting."""
        try:
            # Rate limiting
            self._apply_rate_limit()
            
            # Build API URL
            url = f"{self.NVD_API_BASE}?cveId={cve_id}"
            
            # Make API request
            headers = {
                'User-Agent': 'SAINT-CVE-Enricher/1.0',
                'Accept': 'application/json'
            }
            
            response = requests.get(url, headers=headers, timeout=self.NVD_TIMEOUT)
            self.api_calls += 1
            self.last_api_call = time.time()
            
            response.raise_for_status()
            
            data = response.json()
            
            # Check if CVE was found
            if not data.get('vulnerabilities'):
                logger.warning(f"CVE {cve_id} not found in NVD")
                return None
            
            # Parse CVE data
            vuln_data = data['vulnerabilities'][0]['cve']
            cve_entry = self._parse_cve_data(cve_id, vuln_data)
            
            # Save to database
            session.add(cve_entry)
            session.flush()  # Get the ID
            
            return cve_entry
            
        except requests.exceptions.RequestException as e:
            self.api_errors += 1
            logger.error(f"Failed to fetch CVE {cve_id} from NVD API: {e}")
            return None
        except Exception as e:
            self.api_errors += 1
            logger.error(f"Error processing CVE {cve_id}: {e}")
            return None
    
    def _apply_rate_limit(self):
        """Apply rate limiting for NVD API calls."""
        if self.last_api_call > 0:
            time_since_last = time.time() - self.last_api_call
            min_interval = 1.0 / self.NVD_RATE_LIMIT
            
            if time_since_last < min_interval:
                sleep_time = min_interval - time_since_last
                logger.debug(f"Rate limiting: sleeping {sleep_time:.2f} seconds")
                time.sleep(sleep_time)
    
    def _parse_cve_data(self, cve_id: str, vuln_data: Dict[str, Any]) -> CveEntry:
        """Parse CVE data from NVD API response."""
        # Extract basic information
        descriptions = vuln_data.get('descriptions', [])
        description = ''
        if descriptions:
            # Prefer English description
            for desc in descriptions:
                if desc.get('lang') == 'en':
                    description = desc.get('value', '')
                    break
            if not description and descriptions:
                description = descriptions[0].get('value', '')
        
        # Parse dates
        published_date = self._parse_nvd_date(vuln_data.get('published'))
        modified_date = self._parse_nvd_date(vuln_data.get('lastModified'))
        
        # Extract CVSS scores
        cvss_v3_score, cvss_v3_vector = self._extract_cvss_v3(vuln_data)
        cvss_v2_score, cvss_v2_vector = self._extract_cvss_v2(vuln_data)
        
        # Determine severity
        severity = self._determine_severity(cvss_v3_score, cvss_v2_score)
        
        # Extract CWE IDs
        cwe_ids = self._extract_cwe_ids(vuln_data)
        
        # Extract references
        references = self._extract_references(vuln_data)
        
        # Create CVE entry
        cve_entry = CveEntry(
            cve_id=cve_id,
            description=description[:2000] if description else None,  # Limit length
            published_date=published_date,
            modified_date=modified_date,
            cvss_v3_score=cvss_v3_score,
            cvss_v3_vector=cvss_v3_vector,
            cvss_v2_score=cvss_v2_score,
            cvss_v2_vector=cvss_v2_vector,
            severity=severity,
            cwe_ids=cwe_ids,
            cve_references=references,
            created_date=datetime.now(timezone.utc),
            updated_date=datetime.now(timezone.utc)
        )
        
        return cve_entry
    
    def _parse_nvd_date(self, date_str: str) -> Optional[datetime]:
        """Parse NVD date string to datetime."""
        if not date_str:
            return None
        
        try:
            # NVD uses ISO format with 'Z' suffix
            if date_str.endswith('Z'):
                date_str = date_str[:-1] + '+00:00'
            return datetime.fromisoformat(date_str)
        except ValueError:
            logger.warning(f"Failed to parse date: {date_str}")
            return None
    
    def _extract_cvss_v3(self, vuln_data: Dict[str, Any]) -> tuple:
        """Extract CVSS v3 score and vector."""
        metrics = vuln_data.get('metrics', {})
        
        # Try CVSSv3.1 first, then CVSSv3.0
        for version in ['cvssMetricV31', 'cvssMetricV30']:
            if version in metrics and metrics[version]:
                cvss_data = metrics[version][0].get('cvssData', {})
                score = cvss_data.get('baseScore')
                vector = cvss_data.get('vectorString')
                return score, vector
        
        return None, None
    
    def _extract_cvss_v2(self, vuln_data: Dict[str, Any]) -> tuple:
        """Extract CVSS v2 score and vector."""
        metrics = vuln_data.get('metrics', {})
        
        if 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
            cvss_data = metrics['cvssMetricV2'][0].get('cvssData', {})
            score = cvss_data.get('baseScore')
            vector = cvss_data.get('vectorString')
            return score, vector
        
        return None, None
    
    def _determine_severity(self, cvss_v3_score: Optional[float], cvss_v2_score: Optional[float]) -> Optional[str]:
        """Determine severity based on CVSS scores."""
        score = cvss_v3_score or cvss_v2_score
        
        if not score:
            return None
        
        if score >= 9.0:
            return 'critical'
        elif score >= 7.0:
            return 'high'
        elif score >= 4.0:
            return 'medium'
        else:
            return 'low'
    
    def _extract_cwe_ids(self, vuln_data: Dict[str, Any]) -> Optional[List[str]]:
        """Extract CWE IDs from vulnerability data."""
        weaknesses = vuln_data.get('weaknesses', [])
        cwe_ids = []
        
        for weakness in weaknesses:
            descriptions = weakness.get('description', [])
            for desc in descriptions:
                value = desc.get('value', '')
                if value.startswith('CWE-'):
                    cwe_ids.append(value)
        
        return cwe_ids if cwe_ids else None
    
    def _extract_references(self, vuln_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Extract references from vulnerability data."""
        references = vuln_data.get('references', [])
        
        if not references:
            return None
        
        parsed_refs = []
        for ref in references[:10]:  # Limit to 10 references
            parsed_refs.append({
                'url': ref.get('url'),
                'source': ref.get('source'),
                'tags': ref.get('tags', [])
            })
        
        return {'references': parsed_refs}
    
    def _create_or_update_mapping(self, rule: DetectionRule, cve_entry: CveEntry, session):
        """Create or update rule-to-CVE mapping."""
        # Check if mapping already exists
        existing_mapping = session.query(RuleCveMapping).filter(
            RuleCveMapping.rule_id == rule.id,
            RuleCveMapping.cve_id == cve_entry.id
        ).first()
        
        if existing_mapping:
            # Update timestamp
            existing_mapping.updated_date = datetime.now(timezone.utc)
            self.mappings_updated += 1
            logger.debug(f"Updated CVE mapping: Rule {rule.id} -> {cve_entry.cve_id}")
        else:
            # Create new mapping
            new_mapping = RuleCveMapping(
                rule_id=rule.id,
                cve_id=cve_entry.id,
                relationship_type='references',
                confidence_score=0.9,  # High confidence for pattern matching
                created_date=datetime.now(timezone.utc),
                updated_date=datetime.now(timezone.utc)
            )
            session.add(new_mapping)
            self.mappings_created += 1
            logger.debug(f"Created CVE mapping: Rule {rule.id} -> {cve_entry.cve_id}")
    
    def _create_result_summary(self) -> Dict[str, Any]:
        """Create summary of enrichment results."""
        return {
            'processed_rules': self.processed_count,
            'cves_found': self.cves_found,
            'cves_fetched': self.cves_fetched,
            'cves_cached': self.cves_cached,
            'mappings_created': self.mappings_created,
            'mappings_updated': self.mappings_updated,
            'api_calls': self.api_calls,
            'api_errors': self.api_errors,
            'total_mappings': self.mappings_created + self.mappings_updated
        }

def lambda_handler(event, context):
    """
    Lambda entry point for CVE enrichment.
    
    Event format:
    {
        "rule_ids": [1, 2, 3, ...],  // Optional: specific rules to enrich
        "orchestrator_id": "cve_20241201_120000"  // Optional: tracking ID
    }
    """
    enricher = CveEnricher()
    
    try:
        rule_ids = event.get('rule_ids')
        orchestrator_id = event.get('orchestrator_id', 'manual')
        
        logger.info(f"Starting CVE enrichment (orchestrator: {orchestrator_id})")
        
        result = enricher.enrich_rules(rule_ids)
        
        # Add metadata to result
        result.update({
            'statusCode': 200,
            'orchestrator_id': orchestrator_id,
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'message': 'CVE enrichment completed successfully'
        })
        
        logger.info(f"CVE enrichment complete: {result}")
        return result
        
    except Exception as e:
        error_msg = f"CVE enrichment failed: {e}"
        logger.error(error_msg, exc_info=True)
        return {
            'statusCode': 500,
            'error': str(e),
            'message': error_msg,
            'orchestrator_id': event.get('orchestrator_id', 'manual')
        }